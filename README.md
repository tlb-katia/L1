# Оглавление

1. [Какой самый эффективный способ конкатенации строк?](#какой-самый-эффективный-способ-конкатенации-строк)
2. [Что такое интерфейсы, как они применяются в Go?](#что-такое-интерфейсы-как-они-применяются-в-go)
3. [Чем отличаются RWMutex от Mutex?](#чем-отличаются-rwmutex-от-mutex)
4. [Чем отличаются буферизированные и не буферизированные каналы?](#чем-отличаются-буферизированные-и-не-буферизированные-каналы)
5. [Какой размер у структуры struct{}{}?](#какой-размер-у-структуры-struct)
6. [Есть ли в Go перегрузка методов или операторов?](#есть-ли-в-go-перегрузка-методов-или-операторов)
7. [В какой последовательности будут выведены элементы map[int]int?](#в-какой-последовательности-будут-выведены-элементы-mapintint)
8. [В чем разница make и new?](#в-чем-разница-make-и-new)
9. [Сколько существует способов задать переменную типа slice или map?](#сколько-существует-способов-задать-переменную-типа-slice-или-map)
10. [Что выведет данная программа и почему (вопрос 10)?](#что-выведет-данная-программа-и-почему-вопрос-10)
11. [Что выведет данная программа и почему (вопрос 11)?](#что-выведет-данная-программа-и-почему-вопрос-11)
12. [Что выведет данная программа и почему (вопрос 12)?](#что-выведет-данная-программа-и-почему-вопрос-12)
13. [Что выведет данная программа и почему (вопрос 13)?](#что-выведет-данная-программа-и-почему-вопрос-13)
14. [Что выведет данная программа и почему (вопрос 14)?](#что-выведет-данная-программа-и-почему-вопрос-14)




#### Какой самый эффективный способ конкатенации строк?
В Go есть несколько способов конкатенировать строки, но наиболее эффективным, особенно для больших объемов данных или множественных операций конкатенации, является использование пакета strings.Builder
* strings.Builder содержит внутренний срез байт, который динамически растет по мере добавления данных
* При использовании оператора "+" для конкатенации строк, Go создает новую строку на каждый вызов, что требует выделения новой памяти и копирования данных. В отличие от этого, strings.Builder избегает лишнего выделения памяти, эффективно используя внутренний буфер
```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	var builder strings.Builder

	builder.WriteString("Hello")
	builder.WriteString(", ")
	builder.WriteString("World!")
	
	result := builder.String()
	fmt.Println(result) // Output: Hello, World!
```

#### Что такое интерфейсы, как они применяются в Go?
Интерфейсы в Go — это набор методов, который может быть реализован любым типом. Если тип реализует все методы интерфейса, то он считается реализующим этот интерфейс. Интерфейсы позволяют писать более гибкий и абстрактный код, который может работать с различными типами данных.
```go
package main

import "fmt"

type Speaker interface {
	Speak() string
}

type Dog struct{}

func (d Dog) Speak() string {
	return "Woof!"
}

type Cat struct{}

func (c Cat) Speak() string {
	return "Meow!"
}

func main() {
	var speaker Speaker

	speaker = Dog{}
	fmt.Println(speaker.Speak()) // Output: Woof!

	speaker = Cat{}
	fmt.Println(speaker.Speak()) // Output: Meow!
}
```

#### Чем отличаются RWMutex от Mutex?
* ***Mutex (Mutual Exclusion Lock)*** — это базовый примитив синхронизации, который используется для блокировки критических секций кода, чтобы гарантировать, что только один поток (goroutine) может выполнять код в данной секции в любой момент времени. Это помогает предотвратить состояния гонки.

```go
var mu sync.Mutex

mu.Lock()
// общие данные, доступ к которым нужно синхронизировать
mu.Unlock()
```

* ***RWMutex (Read-Write Mutex)*** — это разновидность Mutex, которая позволяет одновременное чтение множеством потоков, но запрещает запись, когда кто-либо читает или пишет. RWMutex более эффективен в случаях, когда множество горутин в основном читают данные, и записи происходят редко.
```go
var rwMu sync.RWMutex

rwMu.RLock()
// критическая секция для чтения
rwMu.RUnlock()

rwMu.Lock()
// критическая секция для записи
rwMu.Unlock()
```

#### Чем отличаются буферизированные и не буферизированные каналы?

* Не буферизированные каналы требуют одновременного присутствия отправителя и получателя для передачи данных. Они обеспечивают строгую синхронизацию между отправителем и получателем.
```go
ch := make(chan int)

go func() {
ch <- 42 // блокируется, пока кто-то не прочитает
}()

fmt.Println(<-ch) // 42
```

* Буферизированные каналы имеют емкость и позволяют отправлять несколько значений, даже если получатель не готов их немедленно получить. Отправка блокируется только тогда, когда буфер заполнен, а получение — только когда буфер пуст.
```go
ch := make(chan int, 2) // буферизованный канал с емкостью 2

ch <- 1
ch <- 2 // отправка не блокируется, так как есть место в буфере

fmt.Println(<-ch) // 1
fmt.Println(<-ch) // 2
```

#### Какой размер у структуры struct{}{}?
* ***struct{}{}*** — это пустая структура, которая не содержит никаких полей. В Go такие структуры могут использоваться, когда данные не важны, а нужно просто указать на присутствие чего-то (например, для синхронизации или в мапах для ключей без значений).
* Поскольку в структуре нет данных, она не требует памяти для хранения. Поэтому ***размер этой структуры равен 0 байтам***

#### Есть ли в Go перегрузка методов или операторов?
* В Go ***нет*** перегрузки методов или операторов. Это означает, что в Go нельзя определять несколько методов с одинаковым именем, но с разными параметрами, как это можно делать в языках, таких как C++ или Java. Также невозможно перегружать операторы (например, +, -, *) для работы с пользовательскими типами.

* Как обойти отсутствие перегрузки:
    * Использование методов с уникальными именами для каждой операции 
```go
package main

import "fmt"

type Vector struct {
X, Y int
}

func (v Vector) Add(other Vector) Vector {
return Vector{v.X + other.X, v.Y + other.Y}
}

func main() {
v1 := Vector{1, 2}
v2 := Vector{3, 4}

result := v1.Add(v2)
fmt.Println(result) // Output: {4 6}
}
```
* 
  * можно создать отдельные функции для операций
```go
package main

import "fmt"

type Vector struct {
	X, Y int
}

func Add(v1, v2 Vector) Vector {
	return Vector{v1.X + v2.X, v1.Y + v2.Y}
}

func main() {
	v1 := Vector{1, 2}
	v2 := Vector{3, 4}

	result := Add(v1, v2)
	fmt.Println(result) // Output: {4 6}
}

```

### В какой последовательности будут выведены элементы map[int]int?
* В Go элементы из карты (map) не имеют определенной последовательности при итерации. Это связано с тем, что карта в Go реализована на основе хеш-таблицы, и порядок хранения элементов не фиксирован
  Поэтому при итерации по карте с использованием цикла for range порядок вывода элементов может быть произвольным
```go
import "fmt"

func main() {
m := map[int]int{
0: 1,
1: 124,
2: 281,
}

for key, value := range m {
fmt.Printf("m[%d] = %d\n", key, value)
}
}

```

### В чем разница make и new?
* Функция ***new*** используется для выделения памяти под новый экземпляр типа. Она возвращает указатель на новый нулевой (zero-value) экземпляр указанного типа.
```go
var p *int = new(int) // p указывает на целое число, значение которого 0
```

* Функция ***make*** используется для инициализации и выделения памяти для срезов (slices), карт (maps) и каналов (channels). Она возвращает инициализированное значение указанного типа, готовое к использованию
```go
s := make([]int, 10) // Создает срез длиной 10 и инициализирует его нулевыми значениями
m := make(map[string]int) // Создает пустую карту
ch := make(chan int) // Создает канал для передачи целых чисел
```

### Сколько существует способов задать переменную типа slice или map?
##### Создание срезов (slices):
* Литералы срезов:
```go
s := []int{1, 2, 3, 4, 5}
```
* Использование ***make***:
```go
s := make([]int, 5) // Создает срез длиной 5 с нулевыми значениями
s2 := make([]int, 5, 10) // Создает срез длиной 5 и емкостью 10
```
* Создание из существующего среза:
```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:4] // Создает срез [2, 3, 4] из s1
```
* Создание пустого среза:
```go
var s []int // Пустой срез, nil

```

* Инициализация с помощью функции ***copy***:
```go
src := []int{1, 2, 3, 4, 5}
dest := make([]int, len(src))
copy(dest, src)
```

##### Создание карт (maps):
* Литералы карт
```go
m := map[string]int{
"a": 1,
"b": 2,
}
```

* Использование ***make***:
```go
m := make(map[string]int)
```

* Создание карты с начальной емкостью
```go
m := make(map[string]int, 10) // Создает карту с начальной емкостью 10
```

### Что выведет данная программа и почему (вопрос 10)?

```go
func update(p *int) {
b := 2
p = &b
}

func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(p)
fmt.Println(*p)
}
```

***Данная программа выведет 1 и 1***

* Изменения указателя внутри функции update не затрагивают указатель p в функции main, потому что p передается по значению (как копия указателя). Поэтому результаты будут:

* * До вызова функции update: 1
* * После вызова функции update: 1

### Что выведет данная программа и почему (вопрос 11)? 

```go
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}
```

***Данная программа выведет exit***

* Проблема с копией sync.WaitGroup: 
  * Важно понимать, что в горутинах используется копия wg (копия структуры sync.WaitGroup), а не оригинальный объект. Поэтому изменения в этой копии (например, вызов Done()) не влияют на оригинальный wg, который ожидает завершения горутин.

* Исправленная версия 
```go
package main

import (
  "fmt"
  "sync"
)

func main() {
  var wg sync.WaitGroup
  for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(i int) {
      defer wg.Done()
      fmt.Println(i)
    }(i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

### Что выведет данная программа и почему (вопрос 12)? 

```go
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}
```

***Данная программа выведет 0***

* Внутри блока if используется оператор :=, который создает новую переменную n, локальную для этого блока. Эта переменная скрывает (или "затеняет") переменную n, объявленную в main.
* Локальная переменная n внутри if инициализируется значением 1, затем увеличивается на 1, становится равной 2.
* Эта локальная переменная существует только внутри блока if, и после выхода из этого блока она удаляется.

### Что выведет данная программа и почему (вопрос 13)? 
```go
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}

func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}
```

***Данная программа выведет [100 2 3 4 5]***

* В Go срезы (slice) передаются в функции по значению, но при этом передается копия структуры среза, которая содержит указатель на массив, длину и емкость. То есть изменения элементов массива через срез внутри функции отражаются на исходном срезе в вызывающем коде.
* Однако, если в функции выполняется операция append, которая приводит к созданию нового массива (когда емкость среза недостаточна для добавления новых элементов), то создается новый срез, который не влияет на исходный срез в вызывающем коде.


### Что выведет данная программа и почему (вопрос 14)?
```go
func main() {
slice := []string{"a", "a"}

func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}
```

***Данная программа выведет [b b a][a a]***

* Здесь вызывается анонимная функция, в которую передается срез slice.
* Внутри функции, срез slice передается по значению, но он по-прежнему указывает на тот же базовый массив, пока не выполнится операция append.
* При append массив переполняется и возвращается ссылка на новый массив, поэтому мы теперь меняем данные в новом массиве
* Но при этом в main хранится ссылка на старый массив 